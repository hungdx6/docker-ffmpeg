--- a/libavformat/rtmpproto.c	2025-03-03 04:08:21.000000000 +0700
+++ b/libavformat/rtmpproto.c	2025-08-01 17:10:00.700268100 +0700
@@ -134,6 +134,13 @@
     char          auth_params[500];
     int           do_reconnect;
     int           auth_tried;
+    // Reconnection support
+    int           enable_reconnect;       ///< enable automatic reconnection
+    int           reconnect_attempts;     ///< current number of reconnect attempts
+    int           max_reconnect_delay;    ///< maximum delay before giving up (60 seconds)
+    int64_t       last_connect_time;      ///< timestamp of last connection attempt
+    char          *original_url;          ///< original URL for reconnection
+    int           reconnect_delay;        ///< current reconnect delay in milliseconds
 } RTMPContext;
 
 #define PLAYER_KEY_OPEN_PART_LEN 30   ///< length of partial key used for first client digest signing
@@ -163,6 +170,76 @@
 static int handle_window_ack_size(URLContext *s, RTMPPacket *pkt);
 static int handle_set_peer_bw(URLContext *s, RTMPPacket *pkt);
 
+/**
+ * Attempt to reconnect to RTMP server
+ * @param s URLContext
+ * @return 0 on success, negative value on error
+ */
+static int rtmp_reconnect(URLContext *s)
+{
+    RTMPContext *rt = s->priv_data;
+    int ret, i;
+    int64_t current_time = av_gettime();
+    
+    // Check if we should attempt reconnection
+    if (!rt->enable_reconnect) {
+        av_log(s, AV_LOG_ERROR, "Reconnection disabled\n");
+        return AVERROR(EIO);
+    }
+    
+    // Check if we've exceeded the maximum delay
+    if (rt->last_connect_time > 0 && 
+        (current_time - rt->last_connect_time) > rt->max_reconnect_delay * 1000000LL) {
+        av_log(s, AV_LOG_ERROR, "Reconnection timeout exceeded (%d seconds)\n", 
+               rt->max_reconnect_delay);
+        return AVERROR(ETIMEDOUT);
+    }
+    
+    // Exponential backoff delay (start with 1s, max 10s)
+    if (rt->reconnect_attempts > 0) {
+        rt->reconnect_delay = FFMIN(rt->reconnect_delay * 2, 10000);
+        av_log(s, AV_LOG_INFO, "Waiting %d ms before reconnection attempt %d\n", 
+               rt->reconnect_delay, rt->reconnect_attempts + 1);
+        av_usleep(rt->reconnect_delay * 1000);
+    }
+    
+    rt->reconnect_attempts++;
+    av_log(s, AV_LOG_INFO, "Attempting RTMP reconnection (attempt %d)\n", 
+           rt->reconnect_attempts);
+    
+    // Close existing connection
+    if (rt->stream) {
+        ffurl_closep(&rt->stream);
+    }
+    
+    // Reset packet history
+    for (i = 0; i < 2; i++) {
+        int j;
+        for (j = 0; j < rt->nb_prev_pkt[i]; j++)
+            ff_rtmp_packet_destroy(&rt->prev_pkt[i][j]);
+        rt->nb_prev_pkt[i] = 0;
+    }
+    
+    // Reset state but preserve metadata info
+    rt->state = STATE_START;
+    rt->do_reconnect = 0;
+    rt->nb_invokes = 0;
+    rt->flv_off = rt->flv_size; // Reset read position but keep existing data
+    
+    // Free tracked methods
+    free_tracked_methods(rt);
+    
+    // Record reconnection attempt time
+    if (rt->last_connect_time == 0) {
+        rt->last_connect_time = current_time;
+    }
+    
+    // Attempt to reconnect using the original URL
+    av_log(s, AV_LOG_DEBUG, "Reconnecting to %s\n", rt->original_url ? rt->original_url : s->filename);
+    
+    return 0; // Will continue with normal connection process
+}
+
 static int add_tracked_method(RTMPContext *rt, const char *name, int id)
 {
     int err;
@@ -2457,6 +2534,15 @@
             if (ret == 0) {
                 return AVERROR(EAGAIN);
             } else {
+                // Connection error - attempt reconnection if enabled
+                if (rt->enable_reconnect && rt->is_input) {
+                    av_log(s, AV_LOG_WARNING, "RTMP connection lost, attempting reconnection...\n");
+                    if ((ret = rtmp_reconnect(s)) == 0) {
+                        // Signal that we need to reconnect
+                        rt->do_reconnect = 1;
+                        return 0;
+                    }
+                }
                 return AVERROR(EIO);
             }
         }
@@ -2548,6 +2634,7 @@
 
     free_tracked_methods(rt);
     av_freep(&rt->flv_data);
+    av_freep(&rt->original_url);  // Free original URL
     ffurl_closep(&rt->stream);
     return ret;
 }
@@ -2638,6 +2725,23 @@
         rt->listen = 1;
 
     rt->is_input = !(flags & AVIO_FLAG_WRITE);
+    
+    // Initialize reconnection parameters
+    if (rt->is_input) {
+        rt->enable_reconnect = 1;          // Enable reconnect by default for input
+        rt->reconnect_attempts = 0;
+        rt->max_reconnect_delay = 60;      // 60 seconds timeout
+        rt->last_connect_time = 0;
+        rt->reconnect_delay = 1000;        // Start with 1 second delay
+        
+        // Store original URL for reconnection
+        if (!rt->original_url) {
+            rt->original_url = av_strdup(uri);
+            if (!rt->original_url) {
+                return AVERROR(ENOMEM);
+            }
+        }
+    }
 
     av_url_split(proto, sizeof(proto), auth, sizeof(auth),
                  hostname, sizeof(hostname), &port,
@@ -2868,6 +2972,11 @@
             memset(rt->prev_pkt[i], 0,
                    sizeof(**rt->prev_pkt) * rt->nb_prev_pkt[i]);
         free_tracked_methods(rt);
+        
+        av_log(s, AV_LOG_INFO, "Successfully reconnected to RTMP server (attempt %d)\n", 
+               rt->reconnect_attempts);
+        rt->reconnect_attempts = 0;  // Reset on successful reconnection
+        rt->reconnect_delay = 1000;  // Reset delay
         goto reconnect;
     }
 
@@ -2943,8 +3052,17 @@
             rt->flv_off = rt->flv_size;
             return data_left;
         }
-        if ((ret = get_packet(s, 0)) < 0)
-           return ret;
+        
+        ret = get_packet(s, 0);
+        if (ret < 0) {
+            // Check if we need to reconnect
+            if (rt->do_reconnect && rt->enable_reconnect) {
+                av_log(s, AV_LOG_INFO, "Triggering reconnection from rtmp_read\n");
+                rt->do_reconnect = 1;
+                return AVERROR(EAGAIN);  // Signal temporary error
+            }
+            return ret;
+        }
     }
     return orig_size;
 }
@@ -3153,6 +3271,8 @@
     {"listen",      "Listen for incoming rtmp connections", OFFSET(listen), AV_OPT_TYPE_INT, {.i64 = 0}, INT_MIN, INT_MAX, DEC, .unit = "rtmp_listen" },
     {"tcp_nodelay", "Use TCP_NODELAY to disable Nagle's algorithm", OFFSET(tcp_nodelay), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, DEC|ENC},
     {"timeout", "Maximum timeout (in seconds) to wait for incoming connections. -1 is infinite. Implies -rtmp_listen 1",  OFFSET(listen_timeout), AV_OPT_TYPE_INT, {.i64 = -1}, INT_MIN, INT_MAX, DEC, .unit = "rtmp_listen" },
+    {"rtmp_reconnect", "Enable automatic reconnection on connection loss", OFFSET(enable_reconnect), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, DEC},
+    {"rtmp_reconnect_timeout", "Maximum time in seconds to attempt reconnection (default 60)", OFFSET(max_reconnect_delay), AV_OPT_TYPE_INT, {.i64 = 60}, 1, 300, DEC},
     { NULL },
 };
 
